
# ----- Global metrics ------------------------------------------------------- #

"""
    mass(workspace; keep_batchdim = false)

The total mass of the coupling generated by the potentials in `workspace`. If
`keep_batchdim = true`, the batch dimension is retained even if the batchsize
of `workspace` is one.
"""
function mass(w :: Workspace{T, F}; keep_batchdim = false) where {T, F}
  val = sum(marginal(w, w.root, keep_batchdim = true), dims = (1,2))
  val = dropdims(val, dims = (1, 2))
  maybe_drop_batchdim(val, keep_batchdim)
end

"""
    mass_instability(workspace; keep_batchdim = false)

Returns the amplitude of the mass oscillation in the course of a (simulated)
Sinkhorn step.

A large value implies that updating the individual potentials crucially changes
the mass of the coupling at the current stage of iterations. Possible reasons
are:
* the number of steps has not been sufficient for the potentials to converge.
* the targets have different masses and the value of `rho` is set too large,
  enforcing a strict marginal matching that is impossible to achieve since all
  marginals have the same mass.

Note that these two aspects usually interact: a high value of `rho`
(especially when combined with a small value of `eps`) increases the number
of iterations that are necessary before the potentials feel the effect of the
approx operator. However, the thresholding effect of the approx operation is
necessary for mass convergence. In fact, if `eps` is small and `rho` is (too)
high for problems with non-uniform target masses, mass can oscillate for many
iterations.
"""
function mass_instability(w :: Workspace; keep_batchdim = false)
  # copy the workspace to simulate one Sinkhorn step
  wc = copy(w)
  masses = []
  callback = () -> push!(masses, mass(wc; keep_batchdim = true))

  # run the backward and forward pass. after each potential update, call
  # the function defined above
  backward_pass!(wc)
  forward_pass!(wc; callback)

  # get the amplitude
  masses = hcat(masses...)
  diff = maximum(masses, dims = 2) .- minimum(masses, dims = 2)

  # drop dimensions as indicated
  diff = dropdims(diff, dims = 2)
  maybe_drop_batchdim(diff, keep_batchdim)
end

"""
    objective(workspace; keep_batchdim = false)

The dual unbalanced multi-marginal optimal transport objective. If
`keep_batchdim = true`, the batch dimension is retained even if the batchsize
of `workspace` is one.

In theory, this value should monotonically increase with the number of Sinkhorn
steps.

!!! warn

    This function is currently not working as intended.
"""
function objective(w :: Workspace{T, F}; keep_batchdim = false) where {T, F}
  # TOOD: THIS IS BROKEN... But why?
  obj_pot = sum(keys(w.potentials)) do node
    potential = map(MuSink.potential(w, node, keep_batchdim = true)) do val
      val == -Inf ? 0 : -val
    end
    target = MuSink.target(w, node)
    rho = get_rho(w, node)

    approx!(potential, w.problem.penalty, rho, w.eps)
    obj = .- sum(potential .* target, dims = (1, 2))
    dropdims(obj, dims = (1, 2))
  end

  mass_ref = F.(reference_product_mass(w.problem))
  mass = MuSink.mass(w, keep_batchdim = false)
  obj_mass = w.eps .* (mass_ref .- mass)

  obj = obj_pot .+ obj_mass
  maybe_drop_batchdim(obj, keep_batchdim)
end

# ----- Node metrics --------------------------------------------------------- #

"""
    penalty(workspace; weighted = true, keep_batchdim = false)
    penalty(workspace, node; weighted = true, keep_batchdim = false)

Calculate the marginal penalty. If `weighted = true`, the penalties are
multiplied by the `rho` value of the respective node. If `keep_batchdim =
true`, the batch dimension is retained even if the batchsize of `workspace`
is one.
"""
function penalty(w :: Workspace, node; weighted = true, keep_batchdim = false)
  if weighted
    rho = MuSink.get_rho(w, node)
  else
    rho = 1
  end

  if isinf(rho)
    vals = [Inf for _ in size(w.buffer, 3)]
  elseif rho == 0
    vals = [0 for _ in size(w.buffer, 3)]
  else
    marginal = MuSink.marginal(w, node, keep_batchdim = true)
    target = MuSink.target(w, node, keep_batchdim = true)
    vals = w.problem.penalty(marginal, target, rho)
  end
  maybe_drop_batchdim(vals, keep_batchdim)
end

function penalty(w :: Workspace; kwargs...)
  sum(MuSink.nodes(w)) do node
    penalty(node; kwargs...)
  end
end

"""
    marginal_error(workspace; keep_batchdim = false)
    marginal_error(workspace, node; keep_batchdim = false)

Calculate the L1 error between the marginal and target measures. If
`keep_batchdim = true`, the batch dimension is retained even if the batchsize
of `workspace` is one.
"""
function marginal_error(w :: Workspace{T}, node; keep_batchdim = false) where {T}
  target = convert(T, w.problem.targets[node])
  marg = marginal(w, node)
  vals = sum(abs, target .- marg, dims = (1,2))
  vals = dropdims(vals, dims = (1,2))
  maybe_drop_batchdim(vals, keep_batchdim)
end

function marginal_error(w :: Workspace; kwargs...)
  sum(MuSink.nodes(w)) do node
    marginal_error(node; kwargs...)
  end
end

# ----- Edge / coupling metrics ---------------------------------------------- #

"""
    cost(coupling; weighted = true, keep_batchdim = false)
    cost(workspace, a, b; weighted = true, keep_batchdim = false)

Calculate the total transport cost for a `coupling` along the edge `(a, b)`.
If `keep_batchdim = true`, the batch dimension is retained even if the
batchsize of `workspace` is one. If `weighted = true`, the cost value is scaled
by the edge weight.
"""
function cost(plan :: Coupling; weighted = true, keep_batchdim = false)
  values = sum(Reductions.cost(plan), dims = (1, 2))
  weight = weighted ? plan.weights[1] : 1.
  values = weight .* dropdims(values, dims = (1,2))
  maybe_drop_batchdim(values, keep_batchdim)
end

cost(w :: Workspace, a, b; kwargs...) = cost(Coupling(w, a, b); kwargs...)

"""
    cost(workspace; weighted = true, keep_batchdim = false)

Calculate the total transport cost of `workspace`, i.e., the sum of the
transport along all edges in the problem tree.
"""
function cost(w :: Workspace; weighted = true, keep_batchdim = false)
  edges = MuSink.edges_outwards(w)
  sum(edges) do (parent, child)
    cost(w, parent, child; keep_batchdim, weighted)
  end
end

"""
    blur(coupling; reduce = :mean, keep_batchdim = false)

Get the blur of the coupling. It is calculated as the standard deviation of
the mass movement in the forward direction of `coupling`.

The keyword argument `reduce` determines how the pointwise blur values are
summarized. Possible options are `:mean` and `:max`.
If `keep_batchdim = true`, the batch dimension is retained even if the
batchsize of the workspace is one. 

"""
function blur(plan :: Coupling; reduce = :mean, keep_batchdim = false)
  reduce = string(reduce)
  std = map(Reductions.std(plan)) do val
    isnan(val) ? zero(val) : val
  end
  if reduce in ["mean", "average"]
    mass =  sum(plan.marginal_a, dims = (1,2))
    vals = sum(std .* plan.marginal_a, dims = (1,2)) ./ mass
  elseif reduce in ["max", "maximum"]
    vals = maximum(std, dims = (1,2))
  else
    ArgumentError("Unsupported reduction mode :$reduce") |> throw
  end
  vals = dropdims(vals, dims = (1,2))
  maybe_drop_batchdim(vals, keep_batchdim)
end

blur(w :: Workspace, a, b; kwargs...) = blur(Coupling(w, a, b); kwargs...)

"""
    blur(workspace; weighted = true, keep_batchdim = false)

Calculate the total transport cost of `workspace`, i.e., the sum of the
transport along all edges in the problem tree.
"""
function blur(w :: Workspace; reduce = :mean, keep_batchdim = false)
  reduce = string(reduce)
  if reduce in ["mean", "average"]
    blurs = mean(MuSink.edges(w)) do (a, b)
      blur(Coupling(w, a, b); reduce, keep_batchdim)
    end
  elseif reduce in ["max", "maximum"]
    blurs = maximum(MuSink.edges(w)) do (a, b)
      blur(Coupling(w, a, b); reduce, keep_batchdim)
    end
  end
end


# ----- Summarize differences between two workspaces ------------------------- #

function absfinite(x)
  isfinite(x) ? x : zero(x)
end

# TODO: 
function compare_maps(workspace, workspace_2, a, b; reduce = :mean)
end

"""
    compare_potentials(workspace_a, workspace_b; reduce = :mean)

Compare the potentials in `workspace_a` and `workspace_b`.

Both workspaces must be built on top of the same tree.
"""
function compare_potentials(w :: Workspace{T}, ws :: Workspace{T}, node; reduce = :mean) where {T} 
  reduce = string(reduce)

  @assert w.logdomain == ws.logdomain """
  Both workspaces must operate in same domain.
  """

  if w.logdomain && ws.logdomain
    maximum(keys(w.potentials)) do node
      diff = w.potentials[node] .- ws.potentials[node]
      if reduce in ["mean", "average"]
        mean(absfinite, diff)
      elseif reduce == ["max", "maximum"]
        maximum(absfinite, diff)
      end
    end
  else
    maximum(keys(w.potentials)) do node
      potential_a = w.eps .* log.(w.potentials[node])
      potential_b = ws.eps .* log.(ws.potentials[node])
      diff = potential_a .- potential_b
      if reduce in ["mean", "average"]
        mean(absfinite, diff)
      elseif reduce == ["max", "maximum"]
        maximum(absfinite, diff)
      end
    end
  end
end
