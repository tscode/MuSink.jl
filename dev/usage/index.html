<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · MuSink.jl Documentation</title><meta name="title" content="Usage · MuSink.jl Documentation"/><meta property="og:title" content="Usage · MuSink.jl Documentation"/><meta property="twitter:title" content="Usage · MuSink.jl Documentation"/><meta name="description" content="Documentation for MuSink.jl Documentation."/><meta property="og:description" content="Documentation for MuSink.jl Documentation."/><meta property="twitter:description" content="Documentation for MuSink.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MuSink.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#ε-Scaling"><span>ε-Scaling</span></a></li><li><a class="tocitem" href="#Reductions"><span>Reductions</span></a></li><li><a class="tocitem" href="#Relaxing-marginal-constraints"><span>Relaxing marginal constraints</span></a></li><li><a class="tocitem" href="#Barycenters"><span>Barycenters</span></a></li><li><a class="tocitem" href="#Advanced-workspace-options"><span>Advanced workspace options</span></a></li><li><a class="tocitem" href="#Accelerating-MuSink"><span>Accelerating MuSink</span></a></li></ul></li><li><a class="tocitem" href="../reference/">API Reference</a></li><li><a class="tocitem" href="../python/">Python support</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/tscode/MuSink.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/tscode/MuSink.jl/blob/main/docs/src/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>MuSink aims to implement fast and stable UMOT solvers for measures on uniform 2d grids with tree-based cost structures. See section 5 of <a href="https:// arxiv.org/ abs/2103.10854">this publication</a> for the conceptual background.</p><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>In the following, we want to solve a UMOT problem for a temporal sequence of three images. In a first step, we construct the cost tree:</p><pre><code class="language-julia hljs">using MuSink
root = Tree.Root(1)                   # root node with index 1
child_2 = Tree.new_child!(root, 2)    # child with index 2
child_3 = Tree.new_child!(child_2, 3) # child of child 2 with index 3</code></pre><p>Since we only need the root node object in the following code (we usually reference nodes by their index), we could also have written <code>root = Tree.Sequence(3)</code> to accomplish the same goal. Next, we will attach images to each node. These images act as the marginal targets for the UMOT problem</p><pre><code class="language-julia hljs">img1 = zeros(4, 7)
img1[:, 1] .= 1

img2 = zeros(4, 7)
img2[:, 3] .= 1

img3 = zeros(4, 7)
img3[:, 7] .= 1

targets = Dict(
  1 =&gt; img1,
  2 =&gt; img2,
  3 =&gt; img3
)</code></pre><p>In the last line, we assign one image to every node-index of the tree via a dictionary. Alternatively, one can also specify targets via a list / vector <code>targets = [img1, img2, img3]</code>, in wich case images are associated to nodes in order of increasing indices. It is important that all images have the same resolution (<code>4x7</code> in this case).</p><p>The targets in this example tell us that a vertical strip of mass is supposed to move from left (<code>img1</code>) to the middle (<code>img2</code>) to the right (<code>img3</code>) in three time steps. It should be easy to reconstruct this horizontal flow of mass via UMOT.</p><p>To do so, we construct a <code>MuSink.Problem</code>, which collects all of the aspects of a UMOT problem that are unlikely to change.</p><pre><code class="language-julia hljs">problem = Problem(root, targets; cost = Lp(4, 7, p = 2, max = 1), penalty = TotalVariation())</code></pre><p>Here, we provide the <code>MuSink.Problem</code> with the tree topology, the target measures, the cost functional (L2 costs, scaled such that the diagonal corresponds to cost 1), and the penalty between the marginal measures of the solution and the targets (the total variation norm in this case). Additionally, we could also have provided optional reference measures via <code>references = ...</code> and <code>reference_mass = ...</code>. By default, the counting measure is used as reference for each target.</p><p>Now that we have collected the <em>fixed</em> parts of the UMOT problem, we are ready to combine them with the <em>moving</em> parts. This results in a <code>MuSink.Workspace</code>, which is the most important structure in <code>MuSink</code>, as it takes care of essentially all computational aspects. In its basic form, a workspace can be constructed via</p><pre><code class="language-julia hljs">ws = Workspace(problem, eps = 1, rho = Inf)</code></pre><p>There are several other optional arguments that we will come back to later. Important are the arguments <code>eps</code>, which is the strength of the entropic regularization (usually denoted by an ε an mathematical literature), and the parameter <code>rho</code> that influences the strength of the marginal penalty. Rules of thumb:</p><ol><li>larger values of <code>eps</code> will make the resulting coupling more blurry (and the limit of small <code>eps</code> corresponds to the unregularized OT problem),</li><li>larger values of <code>rho</code> will force the marginal measures to better coincide</li></ol><p>with the target measures. The choice <code>rho = Inf</code> basically takes the &#39;U&#39; from   &#39;UMOT&#39; away, as we now are in a setting with strict marginal constraints.</p><p>We are now set to conduct Sinkhorn steps on the object <code>ws</code>, each of which should bring us closer to the true solution of the UMOT problem. In this simple example, <code>10</code> steps should suffice:</p><pre><code class="language-julia hljs">step!(ws, 10)</code></pre><p>Congratulations! You have just calculated the solution to a UMOT problem. Now, what do we do? First, we could check consistency. Since <code>rho = Inf</code> means harsh marginal restrictions, the marginal and the target measures should be very similar:</p><pre><code class="language-julia hljs">target(ws, 1)   # this is just img1 from above
marginal(ws, 1) # this is the first marginal of the coupling after 10 Sinkhorn steps</code></pre><p>We can also calculate the total mass of the solution coupling:</p><pre><code class="language-julia hljs">mass(ws)</code></pre><p>As expected, it amounts to 4, which is also the mass of all of the marginals.</p><p>However, we are far more interested in the actual transport that the workspace currently hides from us. For example, where does the first pixel of the first image go to? The answer is near:</p><pre><code class="language-julia hljs">transport(ws, 1, 2, (1, 1)) # transport of pixel (1, 1) from first to second image
transport(ws, 1, 3, (1, 1)) # transport of pixel (1, 1) from first to third image</code></pre><p>Curiously, this pixel seems to be smeared all over images 2 and 3. Why? This is the consequence of the choice <code>eps = 1</code> from above. If we repeat the Sinkhorn steps with a new workspace and <code>eps = 0.1</code>, the result will be sharper. To get a really crisp result, we can run (usually, smaller <code>eps</code> implies that more steps are needed for convergence)</p><pre><code class="language-julia hljs">set_eps!(ws, 0.01)
step!(ws, 100)
transport(ws, 1, 2, (1, 1))</code></pre><p>Resetting a parameter in this way (which also works for <code>rho</code>, or any other parameter of a workspace), keeps the previously obtained dual solutions in tact and effectively uses them as new initial conditions.</p><h2 id="ε-Scaling"><a class="docs-heading-anchor" href="#ε-Scaling">ε-Scaling</a><a id="ε-Scaling-1"></a><a class="docs-heading-anchor-permalink" href="#ε-Scaling" title="Permalink"></a></h2><p>If we want to calculate sharp transport plans, the value of epsilon has to be quite small. However, this raises some problems. Besides issues of numerical stability in the expdomain (i.e., one usually has to use <code>logdomain = true</code> for stable computations), we find that the smaller the value of <code>eps</code>, the less a single Sinkhorn iteration will impact the potentials and thus the transport plan. Just naively setting <code>eps</code> to something small can therefor be a bad idea and may lead to excessive computational efforts.</p><p>The common strategy to counter this effect is called <em>ε-scaling</em>. The idea is simply to iteratively calculate dual solutions for increasingly smaller values of <code>eps</code>, using the previous solutions as initial values for the next round. This scheme is supported by MuSink.jl via the <code>converge!</code> function.</p><pre><code class="language-julia hljs">ws = Workspace(problem, eps = 1, rho = Inf)
# This will start with eps = 1 and successively scale it down by a factor of 0.85
MuSink.converge!(ws, target_eps = 0.01, scaling = 0.85)</code></pre><p>Instead of a target value of <code>eps</code>, which can be unhelpfully abstract (what does <code>eps = 1e-3</code> mean for the transport plan in a specific problem?), one can also set a target blur value. This value provides a rough intuition into how many target pixels an average source pixel is &quot;blurred&quot; in a standard-deviation sense. You should be careful not to set the value too small, since the solution of the problem may require some amount of mass splitting.</p><pre><code class="language-julia hljs">ws = Workspace(problem, eps = 1, rho = Inf)
MuSink.converge!(ws, target_blur = 1.5)</code></pre><p>In this trivial example, this does not lead to any ε-scalings. In larger images, <code>target_blur</code> is more useful. See the documentation of <code>blur</code> and <code>converge!</code> for more information.</p><h2 id="Reductions"><a class="docs-heading-anchor" href="#Reductions">Reductions</a><a id="Reductions-1"></a><a class="docs-heading-anchor-permalink" href="#Reductions" title="Permalink"></a></h2><p>Except for extracting marginals or finding out how single pixels are moved, what else can we do? For example, we can easily access the dual potentials via <code>potential(ws, index)</code>, where <code>index</code> indexes a node in the problem tree. These potentials can, at least in principle, be used to compute any UMOT-related quantity.</p><p>In practice, the most interesting quantities might involve operations on the transport plan between two nodes. Of course, this can be realized via the pixelwise transport functionalty introduced above (<code>transport(ws, ...)</code>), or even by calling the function <code>dense(ws, index_a, index_b)</code>, which returns the full transport plan. Unfortunately, it is quite expensive to evaluate the full transport plan like this, both in time and memory, and any attemps of this sort will fail miserably on larger images (say 256x256 or 512x512).</p><p>Fortunately, certain properties of the transport plan <em>between neighboring nodes</em> can be computed much faster. This includes the actual transport cost, as well as the &#39;barycentric projection&#39; of the transport plan. The latter is fancy wording for the simple idea of finding the mean target pixel position that mass is transported to, given a source pixel position. Play around with the following methods:</p><pre><code class="language-julia hljs">Reductions.cost(ws, 1, 2) # the pixelwise cost of transport from image 1 to 2
Reductions.imap(ws, 1, 2) # the pixelwise average i-positions (first coordinate)
Reductions.jmap(ws, 1, 2) # the pixelwise average j-positions (first coordinate)
Reductions.ishift(ws, 1, 2) # the pixelwise average i-shift
Reductions.jshift(ws, 1, 2) # the pixelwise average j-shift
Reductions.ivar(ws, 1, 2) # the pixelwise variance of the i-coordinate
Reductions.jvar(ws, 1, 2) # the pixelwise variance of the j-coordinate
Reductions.std(ws, 1, 2) # the pixelwise standard deviation</code></pre><p>For convenience, the aggregate function <code>cost(ws, index_a, index_b)</code> that sums all values from <code>Reductions.cost(ws, index_a, index_b)</code> to a scalar (the total transport cost), is also provided.</p><p>The prefix <code>Reductions</code> for these type of operations is used since they effectively amount to partial weighted summations of the transport plan. If the weights have a suitable structure, an efficient implementation is possible. If you want to define your own Reductions, you can easily do so. For example, the following code constructs and applies a <em>colocalization</em> reduction, which, for each pixel, adds up mass contributions from transport with a cost value <code>&lt;= 0.1</code>.</p><pre><code class="language-julia hljs">colocalize = Reductions.Reduction((diff_i,diff_j,c) -&gt; c &lt;= 0.1)
colocalize(ws, 1, 2)</code></pre><p>The arguments <code>diff_i</code> and <code>diff_j</code>, which we did not make use of in the anonymous function above, correspond to the shift in the first respectively second coordinate. Note that, for technical reasons, the reduction function has to be non-negative. If you want to integrate the plan over negative functions, you have to offset them first, and afterwards subtract the offset again. Alternatively, you can use two reductions, one for the positive / negative part each.</p><p>In case you are interested in the conditional colocalization, this is as simple as <code>colocalize(ws, 1, 2) ./ marginal(ws, 1)</code>, or alternatively <code>colocalize(ws, 1, 2, conditional = true)</code>. If you want to calculate the colocalization between non-adjacent nodes, this is, unfortunately, much harder (or even impossible) to implement efficiently. Currently, this is not supported and <code>colocalize(ws, 1, 3)</code> will error.</p><h2 id="Relaxing-marginal-constraints"><a class="docs-heading-anchor" href="#Relaxing-marginal-constraints">Relaxing marginal constraints</a><a id="Relaxing-marginal-constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Relaxing-marginal-constraints" title="Permalink"></a></h2><p>Up to now, each example used hard marginal constraints (<code>rho = Inf</code>). We next see what happens when we relax them. As we will see, this can be much more tricky than it initially seems.</p><p>Let us just experiment a bit with <code>rho</code>. A first try:</p><pre><code class="language-julia hljs">ws = Workspace(problem, eps = 0.01, rho = 1)
step!(ws, 1000)
marginal(ws, 1)</code></pre><p>Apparantly, this value of <code>rho</code> is still too large to create / destroy mass. Let us go smaller:</p><pre><code class="language-julia hljs">ws = Workspace(problem, eps = 0.01, rho = 0.1)
step!(ws, 1000)
marginal(ws, 1)</code></pre><p>Okay, something has changed. However, it is not clear if this is reasonable. For some reason, the total mass has <strong>increased</strong> by a little bit! See yourself: <code>mass(ws)</code>.</p><p>Let&#39;s continue:</p><pre><code class="language-julia hljs">ws = Workspace(problem, eps = 0.01, rho = 0.01)
step!(ws, 1000)
marginal(ws, 1)</code></pre><p>Now, that is a healthy mixture between reasonable and strange. On the one hand, the marginal now resembles more of a mix of the three marginal measures, just as expected. On the other hand, its total mass has increased greatly! Surely, this is a bug?</p><p>Well, no. This is a real-world consequence of the choice of the counting measure as a reference. The problem is that the product of the three counting measures used as reference has a mass of <code>(4*7)^3 = 21952</code>. Therefore, for small values of <code>rho</code>, where the coupling has no interest in following the marginal constraints, this mass <code>21952</code> will be a point of attraction. In the extreme case of zero costs and <code>rho = 0</code>, we would expect exactly this amount of mass in the coupling. Since the cost function is not zero here, we get a lower value in our example, but still something much larger than 4:</p><pre><code class="language-julia hljs">ws = Workspace(problem, eps = 0.01, rho = 0)
step!(ws, 1000)
mass(ws)</code></pre><p>To further check this hypothesis, we can recalculate the mass under trivial costs:</p><pre><code class="language-julia hljs">problem2 = Problem(root, targets; cost = Lp(4, 7, max = 0))
ws2 = Workspace(problem2, eps = 0.01, rho = 0)
step!(ws2, 1000)
mass(ws2)</code></pre><p>So, what can we then do if we want to decrease <code>rho</code> without letting the mass explode? Maybe it helps if we make <code>eps</code> smaller?. Then, the effect of an high product mass should set in much later.</p><p>Well, looking at the marginals for <code>eps = 0.001</code> and <code>rho = 0.01</code> shows that there is no effect yet (i.e., it works as if <code>rho = Inf</code>). However, if we now decrease <code>rho</code> further, we <strong>lose</strong> mass extremely quickly! Watch this:</p><pre><code class="language-julia hljs">ws = Workspace(problem, eps = 0.001, rho = 0.08) # back to the problem with non-trivial costs
step!(ws, 1000)
mass(ws) # ~ 0.00055...</code></pre><p>This time, instead of exploding, the mass collapses! Reason: at this point, the actual transport (and not the entropic penalty) is the most costly term in the UMOT objective, so transporting nearly no mass is preferable.</p><p>This example should make clear that there is a delicate balance going on, with several competing effects determining how useful the actual solution is. Unfortunately, it is not trivial to predict which magnitudes of <code>eps</code> and <code>rho</code> are suitable and lead to the desired outcomes. However, one universal trick to to stabilize the situation is to set the product reference mass to a reasonable value via</p><pre><code class="nohighlight hljs">problem = Problem(..., reference_mass = 4, ...)</code></pre><p>At least, this prevents mass explosions if <code>eps</code> is too large while <code>rho</code> is too small.</p><h2 id="Barycenters"><a class="docs-heading-anchor" href="#Barycenters">Barycenters</a><a id="Barycenters-1"></a><a class="docs-heading-anchor-permalink" href="#Barycenters" title="Permalink"></a></h2><p>The previous section might have given the impression that reducing <code>rho</code> leads to many disadvantages and is not worth it. However, sometimes it is necessary and safe to do so. For example, if the total masses of the targets would be distinct, then letting <code>rho = Inf</code> would lead to an indefinite oscillation of mass during the Sinkhorn update step (this can be checked via the function <code>MuSink.mass_instability</code>). In this case, finding a suitable value of <code>rho</code> is key for the convergence speed.</p><p>Another scenario where we want to soften marginal constraints are <em>barycenter</em> calculations. Going back to our previous example, we want to set <code>rho = 0</code> <strong>only</strong> for the second node. This effectively means that the marginal for the second node becomes a UMOT-Barycenter of the first and third (see 5.1 in the <a href="https:// arxiv.org/ abs/2103.10854">reference paper</a>). Fortunately, this works well:</p><pre><code class="language-julia hljs">ws = Workspace(problem, eps = 0.01, rho = Inf)
set_rho!(ws, 2, 0)
step!(ws, 1000)
marginal(ws, 2)</code></pre><p>Decreasing <code>eps</code> further will make the barycenter sharper. Since this is central functionality, calculating barycenters has a shortcut implementation. We can thus easily calculate the barycenter of all three images:</p><pre><code class="language-julia hljs">ws = Barycenter([img1, img2, img3], eps = 0.01)
step!(ws, 1000)
marginal(ws, 1) # in this tree, the barycenter can be found on node 1</code></pre><h2 id="Advanced-workspace-options"><a class="docs-heading-anchor" href="#Advanced-workspace-options">Advanced workspace options</a><a id="Advanced-workspace-options-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-workspace-options" title="Permalink"></a></h2><p>When creating a workspace, there is some more flexibility that was previously not mentioned. First, besides the option to set the values of <code>rho</code> for each node seperately, one can also set a <code>weight</code> for any edge in the tree. This weight is multiplied to the default costs. Example:</p><pre><code class="language-julia hljs">ws = Barycenter([img1, img3], eps = 0.01)
set_weight!(ws, 1, 2, 0.2) # cost between the barycenter node and img1 is weakened
step!(ws, 1000)
marginal(ws, 1) # the barycenter has shifted to the right</code></pre><p>Next, when creating a workspace, we can choose the domain that the dual potentials are stored and processed in. It either works in the exponential domain (with auxiliary potentials) or the logarithmic domain (with the actual dual potentials). The former leads to faster computations but becomes unstable for small <code>eps</code>. For this reason, the logdomain is set as default. When you want to change this, you can do so either by setting <code>logdomain = false</code> in the workspace constructor or calling <code>set_logdomain!(ws, false)</code> afterwards.</p><p>One other issue that can affect the stability and performance of the algorithm is the update order within a Sinkhorn step. In each step, all edges of the tree have to be updated in both directions. Different options can be selected via the keyword option <code>stepmode = ...</code> or the <code>set_stepmode!(ws, ...)</code> function. The update order proposed in the <a href="https:// arxiv.org/ abs/2103.10854">reference paper</a> usually works fine, but has a crucial failure mode if the root node equals a node with small <code>rho</code>. For this reason, a stable alternative (<code>stepmode = :stable</code>) without this drawback is implemented as default. This method uses more updates than might be necessary for most problems, so a more aggressive mode (<code>stepmode = :alternate</code>), which should work decently in most settings, is implemented as well.</p><h2 id="Accelerating-MuSink"><a class="docs-heading-anchor" href="#Accelerating-MuSink">Accelerating MuSink</a><a id="Accelerating-MuSink-1"></a><a class="docs-heading-anchor-permalink" href="#Accelerating-MuSink" title="Permalink"></a></h2><p>MuSink supports different array types that workspace operations are based on. By default, <code>Array{Float64}</code> is used. To create a workspace that works with single-floating point precision instead, you can call either of</p><pre><code class="language-julia hljs">ws = Workspace(problem, kwargs..., atype = Array{Float32})
# or
ws = Workspace(problem, kwargs..., atype = :array32)</code></pre><p>Depending on the hardware, this can increase the performance of the workspace. In particular, if the package <code>LoopVectorization</code> is installed and loaded in the same julia session, SIMD optimizations will lead to further performance gains (a factor of 2 or 3).</p><p>On cuda-capable hardware, loading the package <code>CUDA.jl</code> and calling <code>ws = Workspace(..., atype = :cuda32)</code> will create a cuda-accelerated workspace with considerable speedups (depending on the GPU, improvements of a factor of 2 to 20 are possible). Similar options exist for <code>Metal.jl</code> with <code>atype = :metal32</code> or <code>oneAPI.jl</code> with <code>atype = :one32</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../reference/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 28 August 2025 15:14">Thursday 28 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
