var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"MuSink aims to implement fast and stable UMOT solvers for measures on uniform 2d grids with tree-based cost structures. See section 5 of this publication for the conceptual background.","category":"page"},{"location":"usage/#Basics","page":"Usage","title":"Basics","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"In the following, we want to solve a UMOT problem for a temporal sequence of three images. In a first step, we construct the cost tree:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using MuSink\nroot = Tree.Root(1)                   # root node with index 1\nchild_2 = Tree.new_child!(root, 2)    # child with index 2\nchild_3 = Tree.new_child!(child_2, 3) # child of child 2 with index 3","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Since we only need the root node object in the following code (we usually reference nodes by their index), we could also have written root = Tree.Sequence(3) to accomplish the same goal. Next, we will attach images to each node. These images act as the marginal targets for the UMOT problem","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"img1 = zeros(4, 7)\nimg1[:, 1] .= 1\n\nimg2 = zeros(4, 7)\nimg2[:, 3] .= 1\n\nimg3 = zeros(4, 7)\nimg3[:, 7] .= 1\n\ntargets = Dict(\n  1 => img1,\n  2 => img2,\n  3 => img3\n)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In the last line, we assign one image to every node-index of the tree via a dictionary. Alternatively, one can also specify targets via a list / vector targets = [img1, img2, img3], in wich case images are associated to nodes in order of increasing indices. It is important that all images have the same resolution (4x7 in this case).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The targets in this example tell us that a vertical strip of mass is supposed to move from left (img1) to the middle (img2) to the right (img3) in three time steps. It should be easy to reconstruct this horizontal flow of mass via UMOT.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To do so, we construct a MuSink.Problem, which collects all of the aspects of a UMOT problem that are unlikely to change.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"problem = Problem(root, targets; cost = Lp(4, 7, p = 2, max = 1), penalty = TotalVariation())","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here, we provide the MuSink.Problem with the tree topology, the target measures, the cost functional (L2 costs, scaled such that the diagonal corresponds to cost 1), and the penalty between the marginal measures of the solution and the targets (the total variation norm in this case). Additionally, we could also have provided optional reference measures via references = ... and reference_mass = .... By default, the counting measure is used as reference for each target.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now that we have collected the fixed parts of the UMOT problem, we are ready to combine them with the moving parts. This results in a MuSink.Workspace, which is the most important structure in MuSink, as it takes care of essentially all computational aspects. In its basic form, a workspace can be constructed via","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, eps = 1, rho = Inf)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"There are several other optional arguments that we will come back to later. Important are the arguments eps, which is the strength of the entropic regularization (usually denoted by an ε an mathematical literature), and the parameter rho that influences the strength of the marginal penalty. Rules of thumb:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"larger values of eps will make the resulting coupling more blurry (and the limit of small eps corresponds to the unregularized OT problem),\nlarger values of rho will force the marginal measures to better coincide","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"with the target measures. The choice rho = Inf basically takes the 'U' from   'UMOT' away, as we now are in a setting with strict marginal constraints.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We are now set to conduct Sinkhorn steps on the object ws, each of which should bring us closer to the true solution of the UMOT problem. In this simple example, 10 steps should suffice:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"step!(ws, 10)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Congratulations! You have just calculated the solution to a UMOT problem. Now, what do we do? First, we could check consistency. Since rho = Inf means harsh marginal restrictions, the marginal and the target measures should be very similar:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"target(ws, 1)   # this is just img1 from above\nmarginal(ws, 1) # this is the first marginal of the coupling after 10 Sinkhorn steps","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We can also calculate the total mass of the solution coupling:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"mass(ws)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"As expected, it amounts to 4, which is also the mass of all of the marginals.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"However, we are far more interested in the actual transport that the workspace currently hides from us. For example, where does the first pixel of the first image go to? The answer is near:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"transport(ws, 1, 2, (1, 1)) # transport of pixel (1, 1) from first to second image\ntransport(ws, 1, 3, (1, 1)) # transport of pixel (1, 1) from first to third image","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Curiously, this pixel seems to be smeared all over images 2 and 3. Why? This is the consequence of the choice eps = 1 from above. If we repeat the Sinkhorn steps with a new workspace and eps = 0.1, the result will be sharper. To get a really crisp result, we can run (usually, smaller eps implies that more steps are needed for convergence)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"set_eps!(ws, 0.01)\nstep!(ws, 100)\ntransport(ws, 1, 2, (1, 1))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Resetting a parameter in this way (which also works for rho, or any other parameter of a workspace), keeps the previously obtained dual solutions in tact and effectively uses them as new initial conditions.","category":"page"},{"location":"usage/#ε-Scaling","page":"Usage","title":"ε-Scaling","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"If we want to calculate sharp transport plans, the value of epsilon has to be quite small. However, this raises some problems. Besides issues of numerical stability in the expdomain (i.e., one usually has to use logdomain = true for stable computations), we find that the smaller the value of eps, the less a single Sinkhorn iteration will impact the potentials and thus the transport plan. Just naively setting eps to something small can therefor be a bad idea and may lead to excessive computational efforts.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The common strategy to counter this effect is called ε-scaling. The idea is simply to iteratively calculate dual solutions for increasingly smaller values of eps, using the previous solutions as initial values for the next round. This scheme is supported by MuSink.jl via the converge! function.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, eps = 1, rho = Inf)\n# This will start with eps = 1 and successively scale it down by a factor of 0.85\nMuSink.converge!(ws, target_eps = 0.01, scaling = 0.85)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Instead of a target value of eps, which can be unhelpfully abstract (what does eps = 1e-3 mean for the transport plan in a specific problem?), one can also set a target blur value. This value provides a rough intuition into how many target pixels an average source pixel is \"blurred\" in a standard-deviation sense. You should be careful not to set the value too small, since the solution of the problem may require some amount of mass splitting.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, eps = 1, rho = Inf)\nMuSink.converge!(ws, target_blur = 1.5)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In this trivial example, this does not lead to any ε-scalings. In larger images, target_blur is more useful. See the documentation of blur and converge! for more information.","category":"page"},{"location":"usage/#Reductions","page":"Usage","title":"Reductions","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Except for extracting marginals or finding out how single pixels are moved, what else can we do? For example, we can easily access the dual potentials via potential(ws, index), where index indexes a node in the problem tree. These potentials can, at least in principle, be used to compute any UMOT-related quantity.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In practice, the most interesting quantities might involve operations on the transport plan between two nodes. Of course, this can be realized via the pixelwise transport functionalty introduced above (transport(ws, ...)), or even by calling the function dense(ws, index_a, index_b), which returns the full transport plan. Unfortunately, it is quite expensive to evaluate the full transport plan like this, both in time and memory, and any attemps of this sort will fail miserably on larger images (say 256x256 or 512x512).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Fortunately, certain properties of the transport plan between neighboring nodes can be computed much faster. This includes the actual transport cost, as well as the 'barycentric projection' of the transport plan. The latter is fancy wording for the simple idea of finding the mean target pixel position that mass is transported to, given a source pixel position. Play around with the following methods:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Reductions.cost(ws, 1, 2) # the pixelwise cost of transport from image 1 to 2\nReductions.imap(ws, 1, 2) # the pixelwise average i-positions (first coordinate)\nReductions.jmap(ws, 1, 2) # the pixelwise average j-positions (first coordinate)\nReductions.ishift(ws, 1, 2) # the pixelwise average i-shift\nReductions.jshift(ws, 1, 2) # the pixelwise average j-shift\nReductions.ivar(ws, 1, 2) # the pixelwise variance of the i-coordinate\nReductions.jvar(ws, 1, 2) # the pixelwise variance of the j-coordinate\nReductions.std(ws, 1, 2) # the pixelwise standard deviation","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For convenience, the aggregate function cost(ws, index_a, index_b) that sums all values from Reductions.cost(ws, index_a, index_b) to a scalar (the total transport cost), is also provided.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The prefix Reductions for these type of operations is used since they effectively amount to partial weighted summations of the transport plan. If the weights have a suitable structure, an efficient implementation is possible. If you want to define your own Reductions, you can easily do so. For example, the following code constructs and applies a colocalization reduction, which, for each pixel, adds up mass contributions from transport with a cost value <= 0.1.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"colocalize = Reductions.Reduction((diff_i,diff_j,c) -> c <= 0.1)\ncolocalize(ws, 1, 2)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The arguments diff_i and diff_j, which we did not make use of in the anonymous function above, correspond to the shift in the first respectively second coordinate. Note that, for technical reasons, the reduction function has to be non-negative. If you want to integrate the plan over negative functions, you have to offset them first, and afterwards subtract the offset again. Alternatively, you can use two reductions, one for the positive / negative part each.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In case you are interested in the conditional colocalization, this is as simple as colocalize(ws, 1, 2) ./ marginal(ws, 1), or alternatively colocalize(ws, 1, 2, conditional = true). If you want to calculate the colocalization between non-adjacent nodes, this is, unfortunately, much harder (or even impossible) to implement efficiently. Currently, this is not supported and colocalize(ws, 1, 3) will error.","category":"page"},{"location":"usage/#Relaxing-marginal-constraints","page":"Usage","title":"Relaxing marginal constraints","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Up to now, each example used hard marginal constraints (rho = Inf). We next see what happens when we relax them. As we will see, this can be much more tricky than it initially seems.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Let us just experiment a bit with rho. A first try:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, eps = 0.01, rho = 1)\nstep!(ws, 1000)\nmarginal(ws, 1)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Apparantly, this value of rho is still too large to create / destroy mass. Let us go smaller:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, eps = 0.01, rho = 0.1)\nstep!(ws, 1000)\nmarginal(ws, 1)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Okay, something has changed. However, it is not clear if this is reasonable. For some reason, the total mass has increased by a little bit! See yourself: mass(ws).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Let's continue:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, eps = 0.01, rho = 0.01)\nstep!(ws, 1000)\nmarginal(ws, 1)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now, that is a healthy mixture between reasonable and strange. On the one hand, the marginal now resembles more of a mix of the three marginal measures, just as expected. On the other hand, its total mass has increased greatly! Surely, this is a bug?","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Well, no. This is a real-world consequence of the choice of the counting measure as a reference. The problem is that the product of the three counting measures used as reference has a mass of (4*7)^3 = 21952. Therefore, for small values of rho, where the coupling has no interest in following the marginal constraints, this mass 21952 will be a point of attraction. In the extreme case of zero costs and rho = 0, we would expect exactly this amount of mass in the coupling. Since the cost function is not zero here, we get a lower value in our example, but still something much larger than 4:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, eps = 0.01, rho = 0)\nstep!(ws, 1000)\nmass(ws)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To further check this hypothesis, we can recalculate the mass under trivial costs:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"problem2 = Problem(root, targets; cost = Lp(4, 7, max = 0))\nws2 = Workspace(problem2, eps = 0.01, rho = 0)\nstep!(ws2, 1000)\nmass(ws2)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"So, what can we then do if we want to decrease rho without letting the mass explode? Maybe it helps if we make eps smaller?. Then, the effect of an high product mass should set in much later.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Well, looking at the marginals for eps = 0.001 and rho = 0.01 shows that there is no effect yet (i.e., it works as if rho = Inf). However, if we now decrease rho further, we lose mass extremely quickly! Watch this:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, eps = 0.001, rho = 0.08) # back to the problem with non-trivial costs\nstep!(ws, 1000)\nmass(ws) # ~ 0.00055...","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This time, instead of exploding, the mass collapses! Reason: at this point, the actual transport (and not the entropic penalty) is the most costly term in the UMOT objective, so transporting nearly no mass is preferable.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This example should make clear that there is a delicate balance going on, with several competing effects determining how useful the actual solution is. Unfortunately, it is not trivial to predict which magnitudes of eps and rho are suitable and lead to the desired outcomes. However, one universal trick to to stabilize the situation is to set the product reference mass to a reasonable value via","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"problem = Problem(..., reference_mass = 4, ...)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"At least, this prevents mass explosions if eps is too large while rho is too small.","category":"page"},{"location":"usage/#Barycenters","page":"Usage","title":"Barycenters","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The previous section might have given the impression that reducing rho leads to many disadvantages and is not worth it. However, sometimes it is necessary and safe to do so. For example, if the total masses of the targets would be distinct, then letting rho = Inf would lead to an indefinite oscillation of mass during the Sinkhorn update step (this can be checked via the function MuSink.mass_instability). In this case, finding a suitable value of rho is key for the convergence speed.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Another scenario where we want to soften marginal constraints are barycenter calculations. Going back to our previous example, we want to set rho = 0 only for the second node. This effectively means that the marginal for the second node becomes a UMOT-Barycenter of the first and third (see 5.1 in the reference paper). Fortunately, this works well:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, eps = 0.01, rho = Inf)\nset_rho!(ws, 2, 0)\nstep!(ws, 1000)\nmarginal(ws, 2)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Decreasing eps further will make the barycenter sharper. Since this is central functionality, calculating barycenters has a shortcut implementation. We can thus easily calculate the barycenter of all three images:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Barycenter([img1, img2, img3], eps = 0.01)\nstep!(ws, 1000)\nmarginal(ws, 1) # in this tree, the barycenter can be found on node 1","category":"page"},{"location":"usage/#Advanced-workspace-options","page":"Usage","title":"Advanced workspace options","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"When creating a workspace, there is some more flexibility that was previously not mentioned. First, besides the option to set the values of rho for each node seperately, one can also set a weight for any edge in the tree. This weight is multiplied to the default costs. Example:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Barycenter([img1, img3], eps = 0.01)\nset_weight!(ws, 1, 2, 0.2) # cost between the barycenter node and img1 is weakened\nstep!(ws, 1000)\nmarginal(ws, 1) # the barycenter has shifted to the right","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Next, when creating a workspace, we can choose the domain that the dual potentials are stored and processed in. It either works in the exponential domain (with auxiliary potentials) or the logarithmic domain (with the actual dual potentials). The former leads to faster computations but becomes unstable for small eps. For this reason, the logdomain is set as default. When you want to change this, you can do so either by setting logdomain = false in the workspace constructor or calling set_logdomain!(ws, false) afterwards.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"One other issue that can affect the stability and performance of the algorithm is the update order within a Sinkhorn step. In each step, all edges of the tree have to be updated in both directions. Different options can be selected via the keyword option stepmode = ... or the set_stepmode!(ws, ...) function. The update order proposed in the reference paper usually works fine, but has a crucial failure mode if the root node equals a node with small rho. For this reason, a stable alternative (stepmode = :stable) without this drawback is implemented as default. This method uses more updates than might be necessary for most problems, so a more aggressive mode (stepmode = :alternate), which should work decently in most settings, is implemented as well.","category":"page"},{"location":"usage/#Accelerating-MuSink","page":"Usage","title":"Accelerating MuSink","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"MuSink supports different array types that workspace operations are based on. By default, Array{Float64} is used. To create a workspace that works with single-floating point precision instead, you can call either of","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"ws = Workspace(problem, kwargs..., atype = Array{Float32})\n# or\nws = Workspace(problem, kwargs..., atype = :array32)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Depending on the hardware, this can increase the performance of the workspace. In particular, if the package LoopVectorization is installed and loaded in the same julia session, SIMD optimizations will lead to further performance gains (a factor of 2 or 3).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"On cuda-capable hardware, loading the package CUDA.jl and calling ws = Workspace(..., atype = :cuda32) will create a cuda-accelerated workspace with considerable speedups (depending on the GPU, improvements of a factor of 2 to 20 are possible). Similar options exist for Metal.jl with atype = :metal32 or oneAPI.jl with atype = :one32.","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Main-API","page":"API Reference","title":"Main API","text":"","category":"section"},{"location":"reference/#MuSink.Problem","page":"API Reference","title":"MuSink.Problem","text":"MuSink problem type that defines the fixed parts of an UMOT problem.\n\nContains the target and reference measures as well as the cost topology and marginal penalty.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MuSink.Problem-Tuple{Dict{MuSink.Tree.Node, Array{Float64, 3}}}","page":"API Reference","title":"MuSink.Problem","text":"Problem(targets [; cost, penalty, references, reference_mass])\n\nDefault constructor of a MuSink problem.\n\nThe arguments targets and references are expected to be of type Dict{Node, Array{Float64, 3}}, assigning target and reference measures to each node of the tree. If a reference_mass is specified, the references will be scaled such that their product measure has mass reference_mass.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MuSink.Workspace","page":"API Reference","title":"MuSink.Workspace","text":"Core structure for solving UMOT problems. Besides the static properties provided by a Problem (tree topology, target and reference measures, cost and penalty functions), a Workspace also stores various parameters and auxiliary variables of the optimization problem.\n\nWorkspaces are powered by fast implementations of the inner loop of Sinkhorn iterations. These iterations can be performed either in the exponential domain (fast, but breaks down for small regularization parameters eps) or the logarithmic domain (slower, but remains stable for small eps). The domain can be specified via the keyword argument logdomain. The default is logdomain = true.\n\nSinkhorn steps and update rules\n\nSinkhorn steps that modify the Workspace (or, more precisely, the potentials and auxiliary α-arrays stored in the workspace) can conveniently be performed via the step! or steps! function. Based on the array type of the workspace, the properties of the cost function (separable or not), and the operating domain (logdomain or expdomain), specialized kernels are used.\n\nSince the order of the updates can influence the stability / convergence of the algorithm, several different update rules (accessible via the keyword argument stepmode) are implemented:\n\nstepmode = :legacy: a backwards pass through the tree (i.e., updating the value of α-arrays from parents to leaves) is followed by a forward pass (i.e., updating the value of α-arrays from leaves to parents) that also updates the potentials. This update rule is proposed by the authors of the original UMOT manuscript and seems to work fine in most configurations. However, in certain situations, the update rule blocks the propagation of information through the tree, such that potential updates within a step remain unaware of one another. A possible consequence is mass oscillation, which prevents convergence. This behavior is explicit in the barycenter problem (e.g., a star-shaped tree topology where the center node has fixed potentials via rho = 0) IF the root node is set to the center. If the root node is set to a leaf of the tree, stepmode = :legacy should always work.\nstepmode = :stable: a backwards pass through the tree is followed by a mixed forward / backward pass that updates the potentials. This update rule fixes the issues of the :legacy method but also requires more calculations per step.\nstepmode = :alternate: only a mixed forward / backward pass that updates the potentials is conducted. This update rule uses as many computations per step as the :legacy method (i.e., it is faster than the :stable method) but should be protected against harmful information barriers. Still, this method is more aggressive and might thus be more susceptible to instabilities than :stable.\nstepmode = :symmetric: a backwards pass is followed by a forward pass. Both of these passes update the values of α only. Afterwards, all potentials are updated simultaneously. This update rule is severely broken for more than two measures and is subject to change or deprecation\n\nParameters\n\nThe UMOT problem relies on several parameters to be chosen by the user, like the parameters eps (strength of the entropic regularization), reach (the interaction radius), or rho (strength of the marginal penalty). The latter can be set per node. It is additionally possible to specify the weight of individual edges of the tree, which corresponds to a scaling of the cost function along that edge.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MuSink.Workspace-Tuple{Problem}","page":"API Reference","title":"MuSink.Workspace","text":"Workspace(problem::Problem; <keyword arguments>)\n\nCreate a workspace in which problem can be solved by calling step! or converge!.\n\nAll optional arguments arg can also be set via set_[arg]!(ws, ...) after construction.\n\nArguments\n\neps = 1. The Sinkhorn scaling parameter.\nrho = Inf. The default value of the marginal penalty parameter rho.\nrhos. Dictionary that maps nodes to rho values.\nweights. Dictionary that maps edges to values that weight the cost.\nreach = Inf. Reach parameter (radius of maximally allowed transport).\nlogdomain = true. Whether to work in the log or exp domain.\nstepmode = :stable. Strategy that determines the order of potential updates. See the documentation of Workspace for details.\natype = :array64. Array type used in the backend.\n\n\n\n\n\n","category":"method"},{"location":"reference/#MuSink.Chain","page":"API Reference","title":"MuSink.Chain","text":"Chain(targets; kwargs...)\n\nDirectly create a workspace that puts targets in a linear cost tree.\n\nValid keyword arguments are the ones for Problem (except for root) and Workspace.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Barycenter","page":"API Reference","title":"MuSink.Barycenter","text":"Barycenter(targets; kwargs...)\n\nDirectly create a workspace that puts targets in a star-shaped cost tree around a barycenter-node with rho = 0. Valid keyword arguments are the ones for Problem (except for root) and Workspace.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.step!","page":"API Reference","title":"MuSink.step!","text":"step!(ws::Workspace, steps = 1; max_time = Inf, stepmode = ws.stepmode)\n\nPerform steps Sinkhorn update steps with a given stepmode.\n\nThe argument max_time denotes a time limit in seconds, after which no more steps are performed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.converge!","page":"API Reference","title":"MuSink.converge!","text":"converge!(workspace; <keyword arguments>)\n\nAuxiliary method that implements epsilon scaling to approximate the unregularized problem.\n\nArguments:\n\nstart_eps = nothing. Initial value of epsilon. By default, the current epsilon of workspace is used.\ntarget_eps = nothing. Target value of epsilon. By default, determined indirectly via target_blur.\ntarget_blur = nothing. Target value of the average blur of the transport plan. Either this value or target_eps should be passed explicitly.\nscaling = 0.9. Factor by which epsilon is reduced per scaling step.\ntolerance = 1e-2. Convergence tolerance to be achieved before epsilon is scaled down.\ntarget_tolerance = tolerance. Convergence tolerance for the final scaling step.\nmax_time = 600. Maximal time in seconds that the function is allowed to run.\nmax_steps = 10000. Maximal number of steps that the function is allowed to conduct.\ncallback. Procedure that is called after each Sinkhorn step.\ncallback_scaling. Procedure that is called after each (partial) convergence.\nverbose = false. If true, the function documents its progress.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.marginal","page":"API Reference","title":"MuSink.marginal","text":"marginal(ws::Workspace, node; keep_batchdim = false)\n\nThe marginal measure at node with respect to the counting measure.\n\nIf keep_batchdim = true, the singular batch dimension in case of batchsize 1 is not dropped.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.target","page":"API Reference","title":"MuSink.target","text":"target(p::Problem, a)\n\nReturns the target measure of p at node a.\n\n\n\n\n\ntarget(ws::Workspace, node; keep_batchdim = false)\n\nThe target measure at node with respect to the counting measure.\n\nIf keep_batchdim = true, the singular batch dimension in case of batchsize 1 is not dropped.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Couplings-and-transport","page":"API Reference","title":"Couplings and transport","text":"","category":"section"},{"location":"reference/#MuSink.Coupling","page":"API Reference","title":"MuSink.Coupling","text":"Structure that facilitates calculating (parts of) the transport plan between two nodes.\n\nSince the full transport plan is often impractically large, this type provides a lazy interface that operates on the dual potentials.\n\nSome of the operations on Couplings can only be implemented performantly when nodes are adjacent. These operations fail for couplings between non-neighboring nodes.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MuSink.transport","page":"API Reference","title":"MuSink.transport","text":"transport(plan::Coupling, i, j; conditional = false)\ntransport(plan::Coupling, (i, j); conditional = false)\n\ntransport(plan::Coupling, is, js; conditional = false)\ntransport(plan::Coupling, (is, js); conditional = false)\n\ntransport(ws::Workspace, a, b, i, j; conditional = false)\ntransport(ws::Workspace, a, b, (i, j); conditional = false)\n\ntransport(ws::Workspace, a, b, is, js; conditional = false)\ntransport(ws::Workspace, a, b, (is, js); conditional = false)\n\nReturns the evaluation of the coupling plan at pixel (i,j) of node a. If iterables is and js are provided, a vector of transport arrays is returned.\n\nIf conditional = true, the transport arrays sum to one.\n\nIf a workspace ws as well as two nodes a and b are provided, the corresponding coupling is calculated implicitly.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.transport_window","page":"API Reference","title":"MuSink.transport_window","text":"transport_window(plan::Coupling, i, j; conditional = false)\ntransport_window(plan::Coupling, (i, j); conditional = false)\n\ntransport_window(ws::Workspace, a, b, i, j; conditional = false)\ntransport_window(ws::Workspace, a, b, (i, j); conditional = false)\n\nLike transport but returns a window of radius reach around the pixel posiiton (i, j).\n\nnote: Note\nThis function is only implemented for couplings between neighboring nodes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reductions","page":"API Reference","title":"Reductions","text":"","category":"section"},{"location":"reference/#MuSink.Reductions.Reduction","page":"API Reference","title":"MuSink.Reductions.Reduction","text":"Reduction over a coupling.\n\nThis type performantly implements sums of the form\n\nsum_{b} pi_{ab} * f(a-b)\n\nwhere pi is a coupling.\n\nSince evaluation of f takes place in the logdomain, it must return strictly positive values.\n\nnote: Note\nGeneric and efficient implementations are only possible for neighboring nodes. Reductions between non-neighboring nodes are currently not supported.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MuSink.Reductions.reduce","page":"API Reference","title":"MuSink.Reductions.reduce","text":"reduce(r::Reduction, plan; conditional)\nreduce(r::Reduction, workspace, a, b; conditional)\n\nreduction(plan::Coupling; conditional)\nreduction(ws::Workspace, a, b; conditional)\n\nApply the reduction r to a coupling plan or a ws between nodes a and b. If conditional = true, the result is pointwisely divided by the marginal measure of node a.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Predefined-Reductions","page":"API Reference","title":"Predefined Reductions","text":"","category":"section"},{"location":"reference/#MuSink.Reductions.ishift","page":"API Reference","title":"MuSink.Reductions.ishift","text":"ishift(coupling)\nishift(workspace, a, b)\n\nPointwise mean shift in the first component of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.jshift","page":"API Reference","title":"MuSink.Reductions.jshift","text":"jshift(coupling)\njshift(workspace, a, b)\n\nPointwise mean shift in the second component of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.ishiftsq","page":"API Reference","title":"MuSink.Reductions.ishiftsq","text":"ishiftsq(coupling)\nishiftsq(workspace, a, b)\n\nPointwise mean squared shift in the first component of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.jshiftsq","page":"API Reference","title":"MuSink.Reductions.jshiftsq","text":"jshiftsq(coupling)\njshiftsq(workspace, a, b)\n\nPointwise mean squared shift in the second component of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.ivar","page":"API Reference","title":"MuSink.Reductions.ivar","text":"ivar(coupling)\nivar(workspace, a, b)\n\nPointwise variance of the first component of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.jvar","page":"API Reference","title":"MuSink.Reductions.jvar","text":"jvar(coupling)\njvar(workspace, a, b)\n\nPointwise variance of the second component of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.var","page":"API Reference","title":"MuSink.Reductions.var","text":"var(coupling)\nvar(workspace, a, b)\n\nPointwise variance (both components) of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.std","page":"API Reference","title":"MuSink.Reductions.std","text":"var(coupling)\nvar(workspace, a, b)\n\nPointwise standard deviation (both components) of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.imap","page":"API Reference","title":"MuSink.Reductions.imap","text":"imap(coupling)\nimap(workspace, a, b)\n\nPointwise mean position of the first component of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.jmap","page":"API Reference","title":"MuSink.Reductions.jmap","text":"jmap(coupling)\njmap(workspace, a, b)\n\nPointwise mean position of the second component of the transport plan from a to b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Reductions.coloc","page":"API Reference","title":"MuSink.Reductions.coloc","text":"coloc(coupling; threshold, conditional = false)\ncoloc(workspace, a, b; threshold, conditional = false)\n\nColocalization with cost threshold threshold.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Trees","page":"API Reference","title":"Trees","text":"","category":"section"},{"location":"reference/#MuSink.Tree.Node","page":"API Reference","title":"MuSink.Tree.Node","text":"Node type. Carries information about children and its parent node. Has an associated index that can be used to identify it within a tree.\n\nNote that no dedicated Tree type exists. Instead, a root node, which has no parent, encodes the tree-associated structure.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MuSink.Tree.root","page":"API Reference","title":"MuSink.Tree.root","text":"root(a::Node)\n\nReturns the root node of the tree that contains a.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Tree.parent","page":"API Reference","title":"MuSink.Tree.parent","text":"parent(a::Node)\n\nReturns the parent node of a. Returns nothing is a is the root node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Tree.children","page":"API Reference","title":"MuSink.Tree.children","text":"children(a::Node)\n\nReturns all children nodes of a.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.Tree.descendants","page":"API Reference","title":"MuSink.Tree.descendants","text":"descendants(a::Node, include_node = true)\n\nReturns all descendants of a, including a if include_node = true is passed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Querying-workspaces","page":"API Reference","title":"Querying workspaces","text":"","category":"section"},{"location":"reference/#MuSink.get_eps","page":"API Reference","title":"MuSink.get_eps","text":"get_eps(ws::Workspace)\n\nReturns the current value of eps.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.get_rho","page":"API Reference","title":"MuSink.get_rho","text":"get_rho(ws::Workspace)\nget_rho(ws::Workspace, a)\n\nReturns the current value of rho (default or at node a).\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.get_reach","page":"API Reference","title":"MuSink.get_reach","text":"get_reach(ws::Workspace)\n\nReturns the current value of reach.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.get_weight","page":"API Reference","title":"MuSink.get_weight","text":"get_weight(ws::Workspace, a, b)\n\nReturns the cost weight between the nodes a and b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.get_stepmode","page":"API Reference","title":"MuSink.get_stepmode","text":"get_stepmode(ws::Workspace)\n\nReturns the stepmode of ws.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.get_domain","page":"API Reference","title":"MuSink.get_domain","text":"get_domain(ws::Workspace)\n\nReturns true if ws is in the logdomain and false else.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.potential","page":"API Reference","title":"MuSink.potential","text":"potential(ws::Workspace, node; keep_batchdim = false)\n\nThe potential at node. Note that this function always returns the actual dual UMOT potential (i.e., the potential in the logdomain).\n\nIf keep_batchdim = true, the singular batch dimension in case of batchsize 1 is not dropped.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.nodes","page":"API Reference","title":"MuSink.nodes","text":"nodes(p::Problem)\n\nReturns all nodes of the problem cost tree.\n\n\n\n\n\nnodes(ws::Workspace)\n\nReturns all nodes of the problem cost tree.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.edges","page":"API Reference","title":"MuSink.edges","text":"edges(p::Problem)\n\nReturns all (bidirectional) edges of the problem cost tree.\n\n\n\n\n\nedges(ws::Workspace)\n\nReturns all (bidirectional) edges of the problem cost tree.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Modifying-workspaces","page":"API Reference","title":"Modifying workspaces","text":"","category":"section"},{"location":"reference/#MuSink.set_eps!","page":"API Reference","title":"MuSink.set_eps!","text":"set_eps!(ws::Workspace, eps)\n\nSet the value of epsilon to eps. The logdomain potentials are kept.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.set_rho!","page":"API Reference","title":"MuSink.set_rho!","text":"set_rho!(ws::Workspace, rho)\nset_rho!(ws::Workspace, a, rho)\n\nSet the default value of rho to rho. If a node (or node index) a is provided, only set the value for this specific node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.set_reach!","page":"API Reference","title":"MuSink.set_reach!","text":"set_reach!(ws::Workspace, reach::Integer)\n\nSet the reach of ws to reach.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.set_weight!","page":"API Reference","title":"MuSink.set_weight!","text":"set_weight!(w::Workspace, a, b, weight)\n\nSet the cost weight of the edge between a and b to weight\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.set_stepmode!","page":"API Reference","title":"MuSink.set_stepmode!","text":"set_stepmode!(ws::Workspace, stepmode)\n\nSet the step mode of ws to stepmode.\n\n\n\n\n\n","category":"function"},{"location":"reference/#MuSink.set_domain!","page":"API Reference","title":"MuSink.set_domain!","text":"set_domain!(ws::Workspace, logdomain::Bool)\n\nIf logdomain = true, move ws into the logdomain. If logdomain = false, move ws into the expdomain.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Remote-Workspaces","page":"API Reference","title":"Remote Workspaces","text":"","category":"section"},{"location":"reference/#MuSink.Remote.RemoteWorkspace","page":"API Reference","title":"MuSink.Remote.RemoteWorkspace","text":"Structure that enables remote MuSink computations.\n\nRemote workspaces can be constructed like regular ones (see Workspace) and can then be initalized in a separate task / thread / worker via Remote.init.\n\n\n\n\n\n","category":"type"},{"location":"reference/#MuSink.Remote.init","page":"API Reference","title":"MuSink.Remote.init","text":"init(ws::RemoteWorkspace, signal = nothing)\n\nInitialize the remote workspace ws.\n\nA channel signal can be passed, which receives the value true if initialization is successful.\n\n\n\n\n\n","category":"function"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Welcome to the documentation of MuSink.jl.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"MuSink.jl is a julia package that implements unbalanced multi-marginal optimal transport (UMOT), as described by Beier, Lindheim, Neumayer, and Steidl (2022), for 2D grid data (i.e, images).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"You can install it via executing","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg; Pkg.add(\"MuSink\")","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"in a julia shell.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Consult Usage for a tutorial of how to use MuSink.jl.","category":"page"}]
}
